// Copyright 2020 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

module location.nearby.connections.mojom;

import "mojo/public/mojom/base/file.mojom";

// Generic result status of NearbyConnections API calls.
enum Status {
  // The operation was successful.
  kSuccess,
  // The operation failed, without any more information.
  kError,
  // The app called an API method out of order (i.e. another method is expected
  // to be called first).
  kOutOfOrderApiCall,
  // The app already has active operations (advertising, discovering, or
  // connected to other devices) with another Strategy. Stop these operations on
  // the current Strategy before trying to advertise or discover with a new
  // Strategy.
  kAlreadyHaveActiveStrategy,
  // The app is already advertising; call StopAdvertising() before trying to
  // advertise again.
  kAlreadyAdvertising,
  // The app is already discovering; call StopDiscovery() before trying to
  // discover again.
  kAlreadyDiscovering,
  // An attempt to read from/write to a connected remote endpoint failed. If
  // this occurs repeatedly, consider invoking DisconnectFromEndpoint().
  kEndpointIOError,
  // An attempt to interact with a remote endpoint failed because it's unknown
  // to us -- it's either an endpoint that was never discovered, or an endpoint
  // that never connected to us (both of which are indicative of bad input from
  // the client app).
  kEndpointUnknown,
  // The remote endpoint rejected the connection request.
  kConnectionRejected,
  // The app is already connected to the specified endpoint. Multiple
  // connections to a remote endpoint cannot be maintained simultaneously.
  kAlreadyConnectedToEndpoint,
  // The remote endpoint is not connected; messages cannot be sent to it.
  kNotConnectedToEndpoint,
  // There was an error trying to use the device's Bluetooth/WiFi/NFC
  // capabilities.
  kRadioError,
  // An attempt to interact with an in-flight Payload failed because it's
  // unknown to us.
  kPayloadUnknown,
};

// Information about a connection that is being initiated.
struct ConnectionInfo {
  // The name of the remote device we're connecting to.
  string remote_endpoint_name;
  // A short human-readable authentication token that has been given to both
  // devices.
  string authentication_token;
  // The raw (significantly longer) version of the authentication token of
  // authentication_token -- this is intended for headless authentication,
  // typically on devices with no output capabilities, where the authentication
  // is purely programmatic and does not have the luxury of human intervention.
  array<uint8> raw_authentication_token;
  // True if the connection request was initiated from a remote device. False if
  // this device was the one to try and initiate the connection.
  bool is_incoming_connection;
  // Information that represents the remote device.
  array<uint8> endpoint_info;
};

// Information about an endpoint when it's discovered.
struct DiscoveredEndpointInfo {
  // The ID of the service advertised by the remote endpoint.
  string service_id;
  // The human readable name of the remote endpoint.
  string endpoint_name;
  // Information advertised by the remote endpoint.
  array<uint8> endpoint_info;
};

// The Strategy to be used when discovering or advertising to Nearby devices.
// The Strategy defines the connectivity requirements for the device, and the
// topology constraints of the connection.
enum Strategy {
  // Peer-to-peer strategy that supports an M-to-N, or cluster-shaped,
  // connection topology. In other words, this enables connecting amorphous
  // clusters of devices within radio range (~100m), where each device can both
  // initiate outgoing connections to M other devices and accept incoming
  // connections from N other devices.
  kP2pCluster,
  // Peer-to-peer strategy that supports a 1-to-N, or star-shaped, connection
  // topology. In other words, this enables connecting devices within radio
  // range (~100m) in a star shape, where each device can, at any given time,
  // play the role of either a hub (where it can accept incoming connections
  // from N other devices), or a spoke (where it can initiate an outgoing
  // connection to a single hub), but not both.
  kP2pStar,
  // Peer-to-peer strategy that supports a 1-to-1 connection topology. In other
  // words, this enables connecting to a single device within radio range
  // (~100m). This strategy will give the absolute highest bandwidth, but will
  // not allow multiple connections at a time.
  kP2pPointToPoint,
};

// Options for a call to NearbyConnections::StartAdvertising().
struct AdvertisingOptions {
  // The strategy to use for advertising. Must match the strategy used in
  // DiscoveryOptions for remote devices to see this advertisement.
  Strategy strategy;
  // By default, this option is true. If false, we will not attempt to upgrade
  // the bandwidth until a call to InitiateBandwidthUpgrade() is made.
  bool auto_upgrade_bandwidth = true;
  // By default, this option is true. If false, restrictions on topology will be
  // ignored. This allows you treat all strategies as kP2pCluster (N to M),
  // although bandwidth will be severely throttled if you don't maintain the
  // original topology. When used in conjunction with auto_upgrade_bandwidth,
  // you can initially connect as a kP2pCluster and then trim connections until
  // you match kP2pStar or kP2pPointToPoint before upgrading the bandwidth.
  bool enforce_topology_constraints = true;
};

// Options for a call to NearbyConnections::StartDiscovery().
struct DiscoveryOptions {
  // The strategy to use for discovering. Must match the strategy used in
  // AdvertisingOptions in order to see advertisements.
  Strategy strategy;
};

// A simple payload containing raw bytes.
struct BytesPayload {
  // The bytes of this payload.
  array<uint8> bytes;
};

// A file payload representing a file.
struct FilePayload {
  // The file to which this payload points to. When sending this payload, the
  // NearbyConnections library reads from this file. When receiving a file
  // payload it writes to this file.
  mojo_base.mojom.File file;
};

// Union of all supported payload types.
union PayloadContent {
  // A Payload consisting of a single byte array.
  BytesPayload bytes;
  // A Payload representing a file on the device.
  FilePayload file;
};

// A Payload sent between devices. Payloads sent with a particular content type
// will be received as that same type on the other device, e.g. the content for
// a Payload of type BytesPayload must be received by reading from the bytes
// field returned by Payload::content::bytes.
struct Payload {
  // A unique identifier for this payload. Generated by the sender of the
  // payload and used to keep track of the transfer progress.
  int64 id;
  // The content of this payload which is one of multiple types, see
  // PayloadContent for all possible types.
  PayloadContent content;
};

// The status of the payload transfer at the time of this update.
enum PayloadStatus {
  // The payload transfer has completed successfully.
  kSuccess,
  // The payload transfer failed.
  kFailure,
  // The payload transfer is still in progress.
  kInProgress,
  // The payload transfer has been canceled.
  kCanceled,
};

// Describes the status for an active Payload transfer, either incoming or
// outgoing. Delivered to PayloadListener::OnPayloadTransferUpdate.
struct PayloadTransferUpdate {
  // The ID for the payload related to this update. Clients should match this
  // with Payload::id.
  int64 payload_id;
  // The status of this payload transfer. Always starts with kInProgress and
  // ends with one of kSuccess, kFailure or kCanceled.
  PayloadStatus status;
  // The total expected bytes of this transfer.
  uint64 total_bytes;
  // The number of bytes transferred so far.
  uint64 bytes_transferred;
};

// Bandwidth quality of a connection.
enum BandwidthQuality {
  // Unknown connection quality.
  kUnknown,
  // Low quality, e.g. connected via NFC or BLE.
  kLow,
  // Medium quality, e.g. connected via Bluetooth Classic.
  kMedium,
  // High quality, e.g. connected via WebRTC or WiFi LAN.
  kHigh,
};
